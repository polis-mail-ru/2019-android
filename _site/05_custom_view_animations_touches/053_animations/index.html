<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Анимации | Android курс в Технополисе 2019</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Анимации" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/05_custom_view_animations_touches/053_animations/" />
<meta property="og:url" content="http://localhost:4000/05_custom_view_animations_touches/053_animations/" />
<meta property="og:site_name" content="Android курс в Технополисе 2019" />
<script type="application/ld+json">
{"url":"http://localhost:4000/05_custom_view_animations_touches/053_animations/","headline":"Анимации","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=d3418c91688b3f949df607a428f4549250f0b594">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">Android курс в Технополисе 2019</a></h1>
      

      <p>В этом уроке мы познакомимся с анимациями в Android.</p>

<h2 id="анимации">Анимации</h2>

<p>В прошлом уроке мы разобрались как устроен жизненный цикл <code class="highlighter-rouge">View</code>. В Случае, если мы хотим анимировать элемент, то перед <code class="highlighter-rouge">measure</code> будет произведен расчет нового состояния <code class="highlighter-rouge">View</code> для того что бы отобразить следующий шаг анимации.</p>

<p><img src="img/lifecycle.png" width="600" /></p>

<p>В уроке мы рассмотрим следующие способы анимации:</p>

<ul>
  <li>View animation;</li>
  <li>Drawable animation;</li>
  <li>ValueAnimator;</li>
  <li>ObjectAnimator;</li>
  <li>ViewPropertyAnimator;</li>
  <li>Layout transition;</li>
  <li>Transition Framework;</li>
  <li>Dynamic Animation.</li>
</ul>

<h4 id="view-animation">View animation</h4>

<p><code class="highlighter-rouge">View animation</code> - это основной способ анимации <code class="highlighter-rouge">View</code>, который был до Android 2.3. У <code class="highlighter-rouge">View animation</code> есть небольшой набор изменений, которые мы можем сделать с помощью анимации: <code class="highlighter-rouge">alpha</code>, <code class="highlighter-rouge">rotate</code>, <code class="highlighter-rouge">scale</code>, <code class="highlighter-rouge">translate</code>. Главный минус данного подхода состоит в том, что во время анимации не меняется состояние самого <code class="highlighter-rouge">View</code> а меняется лишь отображение представления. Представим, что мы сейчас выполняем какую-то анимацию, например, сдвигаем кнопку. И если в процессе анимации нажать на изначальное местоположение кнопки, то это будет расцениваться как клик по кнопке, хотя, визуально ее там нет. Данный подход устарел, не будем рассматривать его детально.</p>

<h4 id="drawable-animation">Drawable animation</h4>

<p><code class="highlighter-rouge">Drawable animation</code> - это способ покадровой анимации, где каждый кадр, это <code class="highlighter-rouge">Drawable</code>. Описание как правило делается в <code class="highlighter-rouge">xml</code> файле. Такая анимация довольно сложна, т.к. требует загрузки <code class="highlighter-rouge">Drawable</code> на каждый из этапов анимации. Такую анимацию используют в редких случаях, например, когда очень сложно описать происходящее на экране другими способами.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;animation-list</span> <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
    <span class="na">android:oneshot=</span><span class="s">"true"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">android:drawable=</span><span class="s">"@drawable/rocket_thrust1"</span> <span class="na">android:duration=</span><span class="s">"200"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">android:drawable=</span><span class="s">"@drawable/rocket_thrust2"</span> <span class="na">android:duration=</span><span class="s">"200"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;item</span> <span class="na">android:drawable=</span><span class="s">"@drawable/rocket_thrust3"</span> <span class="na">android:duration=</span><span class="s">"200"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/animation-list&gt;</span>
</code></pre></div></div>

<h4 id="valueanimator">ValueAnimator</h4>

<p><code class="highlighter-rouge">ValueAnimator</code> появился в Android 3.0, это базовый движок для анимации. С помощью него можно делать практические любые преобразования. Отличительной особенностью является то, что он никак не привязан к <code class="highlighter-rouge">View</code>. Для работы с <code class="highlighter-rouge">ValueAnimator</code> необходимо указать: начальное значение, конечное значение и <code class="highlighter-rouge">Listener</code> который будет менять какой-либо параметр <code class="highlighter-rouge">View</code>.</p>

<p>Рассмотрим анимацию на примере появляющегося <code class="highlighter-rouge">View</code>, который движется сверху вниз экрана:</p>

<ul>
  <li><code class="highlighter-rouge">View</code> должно поменять свою прозрачность от 0 до 1:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ValueAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="mi">0</span><span class="n">f</span><span class="o">,</span> <span class="mi">1</span><span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">View</code> должно сдвинуться из крайней верхней точки в крайную нижную точку:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ValueAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="mi">0</span><span class="n">f</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">-</span> <span class="n">circle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">());</span>
</code></pre></div></div>

<p>Аниматоры можно комбинировать и управлять ими одновременно:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">animate</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">ValueAnimator</span> <span class="n">alphaAnimator</span> <span class="o">=</span> <span class="n">ValueAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="mi">0</span><span class="n">f</span><span class="o">,</span> <span class="mi">1</span><span class="n">f</span><span class="o">);</span>
    <span class="n">alphaAnimator</span><span class="o">.</span><span class="na">addUpdateListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ValueAnimator</span><span class="o">.</span><span class="na">AnimatorUpdateListener</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAnimationUpdate</span><span class="o">(</span><span class="n">ValueAnimator</span> <span class="n">animation</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">circle</span><span class="o">.</span><span class="na">setAlpha</span><span class="o">((</span><span class="n">Float</span><span class="o">)</span> <span class="n">animation</span><span class="o">.</span><span class="na">getAnimatedValue</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">});</span>


    <span class="kd">final</span> <span class="n">ValueAnimator</span> <span class="n">yAnimator</span> <span class="o">=</span> <span class="n">ValueAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="mi">0</span><span class="n">f</span><span class="o">,</span> <span class="n">root</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">-</span> <span class="n">circle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">());</span>
    <span class="n">yAnimator</span><span class="o">.</span><span class="na">addUpdateListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ValueAnimator</span><span class="o">.</span><span class="na">AnimatorUpdateListener</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAnimationUpdate</span><span class="o">(</span><span class="n">ValueAnimator</span> <span class="n">animation</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">circle</span><span class="o">.</span><span class="na">setY</span><span class="o">((</span><span class="n">Float</span><span class="o">)</span> <span class="n">yAnimator</span><span class="o">.</span><span class="na">getAnimatedValue</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="n">AnimatorSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnimatorSet</span><span class="o">();</span>
    <span class="n">set</span><span class="o">.</span><span class="na">playTogether</span><span class="o">(</span><span class="n">alphaAnimator</span><span class="o">,</span> <span class="n">yAnimator</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">setDuration</span><span class="o">(</span><span class="n">ANIMATION_DURATION</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="img/fade_animation.gif" width="400" /></p>

<p>Давайте рассмотрим как работает движок аниматора. Пускай, мы хотим анимировать целое число от 0 до 255.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ValeValueAnimator</span><span class="o">.</span><span class="na">ofInt</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">255</span><span class="o">);</span>
</code></pre></div></div>

<p>Время в <code class="highlighter-rouge">Animator</code> представляется как значение от 0 до 1. Время обновления экрана в Android это 16ms. Допустим, анимация длится 167 мс, тогда, для отрисовки нам понадобится 10 фреймов. Для примера рассмотрим что происходит во время отрисовки 5го фрейма:</p>

<p>Cначала значение 0.5 попадает в <code class="highlighter-rouge">TimeInterpolator</code>, это функция которая показывает как должна изменяться скорость анимации. Можно, например, сделать что бы анимация разгонялась со временем или наоборот тормозила. Воспользуемся <code class="highlighter-rouge">AccelerateInterpolator</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(x) = x^2
0.5^2 = 0.25
</code></pre></div></div>

<p>Рассчитанное значение подается на вход <code class="highlighter-rouge">TypeEvaluator</code>. <code class="highlighter-rouge">TypeEvaluator</code> определяет как должен меняться объект в процессе анимации относительно времени. В простых случаях это разница конечного и начального значения умноженная на время:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x2 - x1) * t
(255-0) * 0.25 = 63.75
</code></pre></div></div>

<p>Получившееся значение записывается в <code class="highlighter-rouge">Animator</code> и передается в <code class="highlighter-rouge">Listener</code>.</p>

<p>Интерполяторов существует множество, рассмотрим самые базовые:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">AccelerateInterpolator</code>. Определяет функцию с увеличивающейся скоростью. Он, как правило, должен использоваться для элементов, которые собираются пропасть с экрана. Элемент должен большую часть времени элемент провести на экране, чтобы пользователь его точно заметил.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">DecelerateInterpolator</code>. Определяет функцию с уменьшающейся скоростью. Как правило, используется для элементов, которые следует показать на экране.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">AccelerateDecelerateInterpolator</code>. Определяет функцию, скорость которой сначала увеличивается, а потом снижается. Следует использовать для анимации <code class="highlighter-rouge">View</code>, которое будет находится в приделах экрана.</p>
  </li>
</ul>

<p><img src="img/interpolator.gif" width="400" /></p>

<p>В Android 5 появились новые интерполяторы, аналогичные перечисленным выше. Считается, что они работают более плавно и естественно: <code class="highlighter-rouge">FastOutLinearInInterpolator</code>, <code class="highlighter-rouge">LinearOutSlowInInterpolator</code>, <code class="highlighter-rouge">FastOutSlowInInterpolator</code>.</p>

<p>Вернемся к <code class="highlighter-rouge">TypeEvaluator</code>. Как правило не приходится задавать свой <code class="highlighter-rouge">TypeEvaluator</code>, потому-что обычно это мы изменяем достаточно простой величины. Но, если требуется выполнить какие-то не простые манипуляции, то следует определить свой <code class="highlighter-rouge">TypeEvaluator</code>. Например, если мы хотим сделать переливание цветов. Цвет задается в формате ARGB, где на каждый канал отведено по 2 байта. Если мы просто будет анимировать цвет как обычный int, то цвета будут меняться неочевидным образом.</p>

<h4 id="objectanimator">ObjectAnimator</h4>

<p><code class="highlighter-rouge">ObjectAnimator</code> является расширением <code class="highlighter-rouge">ValueAnimator</code>. Все свойства <code class="highlighter-rouge">ValueAnimator</code> также применимы и к <code class="highlighter-rouge">ObjectAnimator</code>. Главным отличием является то, что нам нет необходимости задавать <code class="highlighter-rouge">Listener</code>, вместо этого в <code class="highlighter-rouge">ObjectAnimator</code> представлено понятие <code class="highlighter-rouge">Property</code>, которое отвечает за изменяемый параметр.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ObjectAnimator</span> <span class="n">yAnimator</span> <span class="o">=</span> <span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="n">circle</span><span class="o">,</span> <span class="n">View</span><span class="o">.</span><span class="na">Y</span><span class="o">,</span> <span class="n">circle</span><span class="o">.</span><span class="na">getY</span><span class="o">(),</span> <span class="n">root</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">-</span> <span class="n">circle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">());</span>
</code></pre></div></div>

<p>Давайте рассмотрим, что такое <code class="highlighter-rouge">Property</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Property</span><span class="o">&lt;</span><span class="n">View</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">Y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FloatProperty</span><span class="o">&lt;</span><span class="n">View</span><span class="o">&gt;(</span><span class="s">"y"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">View</span> <span class="n">object</span><span class="o">,</span> <span class="kt">float</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">object</span><span class="o">.</span><span class="na">setY</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Float</span> <span class="nf">get</span><span class="o">(</span><span class="n">View</span> <span class="n">object</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">object</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">};</span>
</code></pre></div></div>

<p>Видно, что <code class="highlighter-rouge">Property</code> по сути делает ту же работу, которую мы обычно делали вручную при использовании <code class="highlighter-rouge">ValueAnimator</code>.</p>

<p><code class="highlighter-rouge">Property</code> можно задавать двумя способами:</p>

<ul>
  <li>с помощью наследника <code class="highlighter-rouge">Property</code>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="n">circle</span><span class="o">,</span> <span class="n">View</span><span class="o">.</span><span class="na">Y</span><span class="o">,</span> <span class="n">circle</span><span class="o">.</span><span class="na">getY</span><span class="o">(),</span> <span class="n">root</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">-</span> <span class="n">circle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">())</span>
</code></pre></div></div>

<ul>
  <li>с помощью строки:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="n">circle</span><span class="o">,</span> <span class="s">"y"</span><span class="o">,</span> <span class="n">circle</span><span class="o">.</span><span class="na">getY</span><span class="o">(),</span> <span class="n">root</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">-</span> <span class="n">circle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">())</span>
</code></pre></div></div>

<p>В случае, если мы используем строку, то доступ к анимируемым полям будет получаться при помощи reflection, что может несколько замедлить работу. А так же, обязательным условием является наличие методов <code class="highlighter-rouge">setX</code> и <code class="highlighter-rouge">getX</code>.</p>

<p>View уже содержат в себе базовый набор <code class="highlighter-rouge">Property</code>:</p>

<ul>
  <li>ALPHA;</li>
  <li>TRANSLATION_X;</li>
  <li>TRANSLATION_Y;</li>
  <li>TRANSLATION_Z;</li>
  <li>X;</li>
  <li>Y;</li>
  <li>Z;</li>
  <li>ROTATION;</li>
  <li>ROTATION_X;</li>
  <li>ROTATION_Y;</li>
  <li>SCALE_X;</li>
  <li>SCALE_Y.</li>
</ul>

<h4 id="viewpropertyanimator">ViewPropertyAnimator</h4>

<p><code class="highlighter-rouge">ViewPorpertyAnimator</code> также работает на основе <code class="highlighter-rouge">ValueAnimator</code>. Главный плюс <code class="highlighter-rouge">ViewPorpertyAnimator</code> состоит в том, что он предоставляет удобный API для анимации <code class="highlighter-rouge">View</code>. В случае анимирования нескольких значений, он может быть незначительно быстрее <code class="highlighter-rouge">ObjectAnimator</code>. Минусом является то, что нам нельзя анимировать какие-то свои параметры, можно использовать только те, которые есть в стандартном наборе.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">ViewPropertyAnimator</span> <span class="n">yAnimator</span> <span class="o">=</span> <span class="n">circle</span><span class="o">.</span><span class="na">animate</span><span class="o">().</span><span class="na">x</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()</span> <span class="o">-</span> <span class="n">circle</span><span class="o">.</span><span class="na">getHeight</span><span class="o">()).</span><span class="na">setDuration</span><span class="o">(</span><span class="n">ANIMATION_DURATION</span><span class="o">).</span><span class="na">setInterpolator</span><span class="o">(</span><span class="n">interpolator</span><span class="o">);</span>
</code></pre></div></div>

<p>#### Какой аниматор выбрать?</p>

<p>Мы рассмотрели несколько способов, с помощью которых можно анимировать <code class="highlighter-rouge">View</code>, давайте определимся с тем, когда следует использовать каждый из предложенных вариантов:</p>

<ul>
  <li><code class="highlighter-rouge">ViewAnimation</code>. Устаревший. Лучше не использовать;</li>
  <li><code class="highlighter-rouge">DrawableAnimation</code>. Использовать только в очень сложных случаях;</li>
  <li><code class="highlighter-rouge">ValueAnimator</code>. Стоит использовать только в тех случаях, когда нам не удается написать <code class="highlighter-rouge">Property</code>;</li>
  <li><code class="highlighter-rouge">ObjectAnimator</code>. Стоит использовать по возможности всегда;</li>
  <li><code class="highlighter-rouge">ViewPropertyAnimator</code>. Стоит использовать для простых случаев.</li>
</ul>

<p>#### Завершение анимации</p>

<p>Для того, что завершить анимацию, раньше чем ее завершит аниматор следует использовать следующие способы:</p>

<ul>
  <li><code class="highlighter-rouge">view.clearAnimation()</code>. Для <code class="highlighter-rouge">View animation</code>;</li>
  <li><code class="highlighter-rouge">animator.cancel()</code>. Для <code class="highlighter-rouge">ValueAnimator</code> и <code class="highlighter-rouge">ObjectAnimator</code>;</li>
  <li><code class="highlighter-rouge">view.animate().cancel()</code>. Для <code class="highlighter-rouge">ViewPropertyAnimator</code>.</li>
</ul>

<p>В случае вызова неверного метода, анимация не будет остановлена.Лучше всегда сохранять ссылку на аниматор, для того, что бы можно было остановить анимацию в любой момент. Также, следует останавливать анимации в методах:</p>

<ul>
  <li><code class="highlighter-rouge">Activity.onStop()</code>;</li>
  <li><code class="highlighter-rouge">Fragment.onStop()</code>;</li>
  <li><code class="highlighter-rouge">View.onDetachFromWidow()</code>.</li>
</ul>

<p>Это следует делать во избежание утечек памяти.</p>

<h4 id="layouttransition">LayoutTransition</h4>

<p><code class="highlighter-rouge">LayoutTransition</code>(флаг <code class="highlighter-rouge">animateLayoutChanges</code>) работает на основе <code class="highlighter-rouge">ValueAnimator</code>. Позволяет при изменениях внутри дочерних <code class="highlighter-rouge">View</code> анимировать родительский <code class="highlighter-rouge">View</code>.</p>

<p>Подходит для простых случаев:</p>

<ul>
  <li>Появление;</li>
  <li>Исчезновение;</li>
  <li>Изменение размеров.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">root</span><span class="o">.</span><span class="na">setLayoutTransition</span><span class="o">(</span><span class="k">new</span> <span class="n">LayoutTransition</span><span class="o">());</span>
</code></pre></div></div>

<p><img src="img/layout_transition.gif" width="400" /></p>

<p>Анимация запускается только для последнего действия. Например, если в одной иерархии мы захотим и добавить и удалить <code class="highlighter-rouge">View</code>, то анимация запустится только для последнего действия, то есть для удаления <code class="highlighter-rouge">View</code>.</p>

<h4 id="transition-framework">Transition Framework</h4>

<p><code class="highlighter-rouge">Transition Framework</code> вводит такие понятия, как <code class="highlighter-rouge">Transition</code>, который включает в себя целый класс анимаций. <code class="highlighter-rouge">Transition Framework</code> анимирует всю иерархию внутри контейнера, не только ближайшие вложенные элементы, а все, которые находятся в заданном родителе. Данный фрейморк работает только для Android 4.4 и выше.</p>

<p>Для того, что бы задать анимацию, достаточно описать какие эффекты мы хотим применять к изменениям лейаута, а дальше выполнить метод <code class="highlighter-rouge">beginDelayedTransition</code>. Далее, все изменения родителя будут анимрованы указанным способом.</p>

<p>Добиться анимации как в предыдущем случае можно при помощи следующего кода:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TransitionSet</span> <span class="n">transitionSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TransitionSet</span><span class="o">().</span><span class="na">addTransition</span><span class="o">(</span><span class="k">new</span> <span class="n">Fade</span><span class="o">());</span>
<span class="n">TransitionManager</span><span class="o">.</span><span class="na">beginDelayedTransition</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">transitionSet</span><span class="o">);</span>
<span class="n">circle2</span><span class="o">.</span><span class="na">setVisibility</span><span class="o">(</span><span class="n">View</span><span class="o">.</span><span class="na">VISIBLE</span><span class="o">);</span>
</code></pre></div></div>

<p>Кроме базовых анимаций есть несколько необычных, например Slide. Этот способ анимации заставляет <code class="highlighter-rouge">View</code> “прилететь” в заданную позицию:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TransitionSet</span> <span class="n">transitionSet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TransitionSet</span><span class="o">().</span><span class="na">addTransition</span><span class="o">(</span><span class="k">new</span> <span class="n">Fade</span><span class="o">()).</span><span class="na">addTransition</span><span class="o">(</span><span class="k">new</span> <span class="n">Slide</span><span class="o">();</span>
<span class="n">TransitionManager</span><span class="o">.</span><span class="na">beginDelayedTransition</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">transitionSet</span><span class="o">);</span>
<span class="n">circle2</span><span class="o">.</span><span class="na">setVisibility</span><span class="o">(</span><span class="n">View</span><span class="o">.</span><span class="na">VISIBLE</span><span class="o">);</span>
</code></pre></div></div>

<p><img src="img/slide.gif" width="400" /></p>

<p>Кроме заданного набора анимация, можно реализовать свои анимации. На, следует помнить, что на <code class="highlighter-rouge">Transition Framework</code> накладывает ограничения ограничение на минимальную версию Android.</p>

<p>Что лучше использовать <code class="highlighter-rouge">LayoutTransition</code> или <code class="highlighter-rouge">Transition Framework</code>? <code class="highlighter-rouge">LayoutTransition</code> стоит использовать для простых иерархий, где анимируется не большое количество элементов и/или для старых версий Android. <code class="highlighter-rouge">Transition Framework</code> следует использовать для более сложных случаях и/или для новых версий Android.</p>

<h4 id="dynamic-animation">Dynamic Animation</h4>

<p>Мы живем в реальном мире, который подчиняется физическим законам и взаимодействую с интерфейсом, человеку хочется что бы интерфейс реагировал также привычным образом. Для это в Android добавлена библиотека <code class="highlighter-rouge">Dynamic animation</code>, или также известна как <code class="highlighter-rouge">Physic-based animation</code>.</p>

<p>Сравните как выглядят анимации. Слева обычная анимация, справа <code class="highlighter-rouge">Physic-based animation</code>:</p>

<p><img src="img/physics.gif" width="800" /></p>

<p>На текущий момент библиотека включает в себя два вида анимаций, <code class="highlighter-rouge">FlingAnimation</code> и <code class="highlighter-rouge">SpringAnimation</code>.</p>

<ul>
  <li><code class="highlighter-rouge">FlingAnimation</code>. Предназначена для тех случаев, когда пользователь своими жестами инициирует какую-то анимацию, например свайп: когда пользователь поднимает палец, элемент должен сдвинуться примерно с той же самой скоростью, с которой пользователь двигал палец.</li>
</ul>

<p><img src="img/fling.gif" width="400" /></p>

<ul>
  <li><code class="highlighter-rouge">SpringAnimation</code>. Анимация отмены действия или возврата к начальному состоянию. Чем-то похожа на пружину.</li>
</ul>

<p><img src="img/spring.gif" width="400" /></p>

<p>Пример использования Dynamic Animation можно посмотреть <a href="https://github.com/otopba/polis-mail-ru-rv-swipe-sample">тут</a></p>

<h4 id="прочие-анимации">Прочие анимации</h4>

<p>Кроме анимаций, которые могут применяться к любым View, есть анимации, которые предназначены для каких-то определенных ситуаций. Например:</p>

<ul>
  <li><code class="highlighter-rouge">ItemAnimator</code>. Этот аниматор работает только в <code class="highlighter-rouge">RecyclerView</code></li>
  <li><code class="highlighter-rouge">AnimatedVectorDrawable</code>. Аниматор для работы с векторными изображениями;</li>
  <li><code class="highlighter-rouge">Activity Transition</code>. Способ анимации между <code class="highlighter-rouge">Activity</code>;</li>
  <li><code class="highlighter-rouge">Fragment Transition</code>. Способ анимации между фрагментами.</li>
</ul>

<p>Android постоянно обновляется и вместе с тем добавляются новые способы анимации объектов. С умом подойдите в выбору способа анимации и следите за обновлениями.</p>

<h2 id="что-почитать">Что почитать</h2>

<p>https://developer.android.com/guide/topics/graphics/view-animation
https://habr.com/ru/company/yandex/blog/344296/
https://android.jlelse.eu/android-physics-based-animation-cf0cc125830f</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
