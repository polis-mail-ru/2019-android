<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Custom View | Android курс в Технополисе 2019</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Custom View" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/05_custom_view_animations_touches/051_custom_view/" />
<meta property="og:url" content="http://localhost:4000/05_custom_view_animations_touches/051_custom_view/" />
<meta property="og:site_name" content="Android курс в Технополисе 2019" />
<script type="application/ld+json">
{"url":"http://localhost:4000/05_custom_view_animations_touches/051_custom_view/","headline":"Custom View","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=d3418c91688b3f949df607a428f4549250f0b594">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">Android курс в Технополисе 2019</a></h1>
      

      <p>В этом уроке мы научимся создавать собственные <code class="highlighter-rouge">View</code>.</p>

<h2 id="custom-view">Custom View</h2>

<p>Обычно термин <code class="highlighter-rouge">Custom View</code> обозначает <code class="highlighter-rouge">View</code>, которого нет в sdk Android. Или другими словами - это <code class="highlighter-rouge">View</code> которое мы сделали сами.</p>

<p>Когда может понадобиться реализация собственного <code class="highlighter-rouge">View</code>:</p>

<ul>
  <li>специфичная отрисовка;</li>
  <li>специфичная обработка жестов;</li>
  <li>оптимизация существующих элементов;</li>
  <li>правка багов в существующем элементе.</li>
</ul>

<p>Как правило, создание custom view можно избежать используя темы, различные параметры <code class="highlighter-rouge">View</code>, а иногда и лисенеры. Но, если все таки вам действительно нужно сделать что-то особенное, давайте разберемся как же это сделать.</p>

<p>Для начала, давайте вспомним о том, как выглядит иерархия базовых компонентов:</p>

<p><img src="img/hierarchy.png" width="1200px" /></p>

<p>Все ui компоненты наследуются от <code class="highlighter-rouge">View</code>, а лейауты от <code class="highlighter-rouge">ViewGroup</code>. В свою очередь ViewGroup наследуется от <code class="highlighter-rouge">View</code>.</p>

<p>Прежде чем наследоваться от базового класса <code class="highlighter-rouge">View</code> посмотрите, может быть вам ближе функциональность уже какого-то существующего элемента. Например <code class="highlighter-rouge">Button</code>, это не написанный с нуля компонент, а наследник <code class="highlighter-rouge">TextView</code>.</p>

<h2 id="жизненный-цикл-view">Жизненный цикл View</h2>

<p>Первостепенно давайте разберемся с жизненным циклом <code class="highlighter-rouge">View</code>.</p>

<p><img src="img/live_cycle.png" width="1200px" /></p>

<h4 id="constructor">Constructor</h4>

<p>Каждый элемент начинает свое существование с конструктора. У <code class="highlighter-rouge">View</code> их целых четыре штуки:</p>

<p>Создание View из кода:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">CustomView</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span>
</code></pre></div></div>

<p>Создание View из XML:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">CustomView</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">AttributeSet</span> <span class="n">attrs</span><span class="o">);</span>
</code></pre></div></div>

<p>Создание View из XML со стилем из темы:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">CustomView</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">AttributeSet</span> <span class="n">attrs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">defStyleAttr</span><span class="o">);</span>
</code></pre></div></div>

<p>Создание View из XML со стилем из темы и/или с ресурсом стиля:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">CustomView</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="n">AttributeSet</span> <span class="n">attrs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">defStyleAttr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">defStyleRes</span><span class="o">)</span>
</code></pre></div></div>

<p>Последний конструктор добавлен в sdk версии 21. Каждый из конструктор каскадно вызывает следующий.</p>

<h4 id="onattachedtowindow">onAttachedToWindow</h4>

<p>После того как родитель <code class="highlighter-rouge">View</code> вызовет метод <code class="highlighter-rouge">addView(View)</code>, наш <code class="highlighter-rouge">View</code> будет прикреплён к окну. На этой стадии наш View-компонент попадает в иерархию родителя.</p>

<h4 id="onmeasure">onMeasure</h4>

<p>Этот метод означает, что наш <code class="highlighter-rouge">View</code> находится на стадии определения собственного размера. Для того что бы понять как распределить элементы на экране и сколько они занимают место нужно получить от каждого <code class="highlighter-rouge">View</code> его размер. В методе <code class="highlighter-rouge">measure</code> как раз и происходят расчеты.</p>

<p>Давайте посмотрим на сам метод:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onMeasure</span><span class="o">(</span><span class="kt">int</span> <span class="n">widthMeasureSpec</span><span class="o">,</span> <span class="kt">int</span> <span class="n">heightMeasureSpec</span><span class="o">)</span>
</code></pre></div></div>

<p>Метод <code class="highlighter-rouge">onMeasure()</code> принимает 2 аргумента: <code class="highlighter-rouge">widthMeasureSpec</code> и <code class="highlighter-rouge">heightMeasureSpec</code>. Это значения, которые содержат в себе информацию о том, каким размером хочет видеть ваше <code class="highlighter-rouge">View</code> родительский элемент.</p>

<p>Каждое из значений на самом деле содержит 2 параметра:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">size</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">mode</code>. Указывает на то, какие правила применяются ко второму параметру size;</li>
  <li><code class="highlighter-rouge">size</code>. Непосредственно размер <code class="highlighter-rouge">View</code>.</li>
</ul>

<p>Получить эти параметры можно при помощи методов класса <code class="highlighter-rouge">MeasureSpec</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MeasureSpec</span><span class="o">.</span><span class="na">getMode</span><span class="o">(</span><span class="n">widthMeasureSpec</span><span class="o">)</span>
<span class="n">MeasureSpec</span><span class="o">.</span><span class="na">getSize</span><span class="o">(</span><span class="n">widthMeasureSpec</span><span class="o">)</span>
</code></pre></div></div>

<p>mode может принимать следующие значения:</p>

<ul>
  <li><code class="highlighter-rouge">MeasureSpec.EXACTLY</code>. Означает, что размер задан жёстко. Независимо от размера вашего <code class="highlighter-rouge">View</code>, вы должны установить определённую ширину и высоту;</li>
  <li><code class="highlighter-rouge">MeasureSpec.AT_MOST</code>. Означает что <code class="highlighter-rouge">View</code> может быть любого размера, которого пожелает, но, не больше чем размер родителя. Это значение <code class="highlighter-rouge">match_parent</code>;</li>
  <li><code class="highlighter-rouge">MeasureSpec.UNSPECIFIED</code>. Означение что <code class="highlighter-rouge">View</code> может само решить какой размер ему нужен не взирая ни на какие ограничения. Это значение <code class="highlighter-rouge">wrap_content</code>.</li>
</ul>

<p>В коде это можно описать следующим образом:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">width</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">widthMode</span> <span class="o">==</span> <span class="n">MeasureSpec</span><span class="o">.</span><span class="na">EXACTLY</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">widthSize</span><span class="o">;</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">widthMode</span> <span class="o">==</span> <span class="n">MeasureSpec</span><span class="o">.</span><span class="na">AT_MOST</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">wrapWidth</span><span class="o">,</span> <span class="n">widthSize</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">wrapWidth</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>где <code class="highlighter-rouge">wrapWidth</code>, это наша желаемая ширина. Аналогичный подход применяется и к высоте <code class="highlighter-rouge">View</code>.</p>

<p>Конечно же не нужно каждый раз писать эту конструкцию из условий. Для упрощения работы у View есть метод</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">resolveSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="kt">int</span> <span class="n">measureSpec</span><span class="o">)</span>
</code></pre></div></div>

<p>который уже включает в себя все необходимые условия.</p>

<p>После того как мы выполнили все расчеты, необходимо установить рассчитанные размеры при помощи метода:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setMeasuredDimension</span><span class="o">(</span><span class="kt">int</span> <span class="n">measuredWidth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">measuredHeight</span><span class="o">)</span>
</code></pre></div></div>

<p>Расчет размера можно разделить на 4 стадии:</p>

<ol>
  <li>Родитель узнает “пожелания”, каким размером <code class="highlighter-rouge">View</code> хочет быть, определение <code class="highlighter-rouge">LayoutParams</code> наследника. Это может быть сделано как через xml, так и кодом:</li>
</ol>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>android:layout_width="match_parent"
android:layout_height="wrap_content"
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LinearLayout</span><span class="o">.</span><span class="na">LayoutParams</span>
</code></pre></div></div>

<p><img src="img/measure_1_step.jpg" width="600" /></p>

<ol>
  <li>Родитель начинает измерять свои дочерние <code class="highlighter-rouge">View</code> и просит рассчитать их размеры.</li>
</ol>

<p><img src="img/measure_2_step.jpg" width="600" /></p>

<ol>
  <li>Дочерняя View рассчитывает свои размеры и устанавливает значение.</li>
</ol>

<p><img src="img/measure_3_step.jpg" width="600" /></p>

<ol>
  <li>Родитель сообщает о том, что расчет закончен и можно получить финальные значения.</li>
</ol>

<p><img src="img/measure_4_step.jpg" width="600" /></p>

<h4 id="onlayout">onLayout</h4>

<p>Этот метод позволяет присваивать позицию и размер дочерним элементам <code class="highlighter-rouge">ViewGroup</code>. В случае, если мы наследовались от <code class="highlighter-rouge">View</code>, нам не нужно переопределять этот метод.</p>

<h4 id="ondraw">onDraw</h4>

<p>Это основной метод при разработки собственной <code class="highlighter-rouge">View</code>. В <code class="highlighter-rouge">onDraw</code> вы можете рисовать все что вам нужно. Метод имеет следующую сигнатуру:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDraw</span><span class="o">(</span><span class="n">Canvas</span> <span class="n">canvas</span><span class="o">)</span>
</code></pre></div></div>

<p>На полученном <code class="highlighter-rouge">Canvas</code> вам требуется непосредственно изобразить саму <code class="highlighter-rouge">View</code>. Рисование на <code class="highlighter-rouge">Canvas</code> происходит при мощи объекта <code class="highlighter-rouge">Paint</code>. <code class="highlighter-rouge">Paint</code> отвечает за то, как именно будет отрисован контент вашего <code class="highlighter-rouge">View</code> и имеет множество параметров.</p>

<p>Стоит обратить внимание, что <code class="highlighter-rouge">onDraw</code> вызывается не один раз и может занимать много времени. Поэтому стоит максимально аккуратно работать с отрисовкой, не аллоцировать никаких объектов и не делать лишних операций.</p>

<h4 id="обновление-view">Обновление View</h4>

<p>Из диаграммы жизненного цикла видно, что существуют два метода, которые заставляют <code class="highlighter-rouge">View</code> перерисовываться:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">invalidate()</code>. Используется когда нужно только перерисовать ваш элемент. Когда изменился цвет или текст или нужно сделать какие-то еще визуальные изменения;</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">requestLayout()</code>. Используется когда нужно изменить размеры вашего <code class="highlighter-rouge">View</code>. Вызов <code class="highlighter-rouge">requestLayout</code> не только заставит <code class="highlighter-rouge">View</code> заново измериться, но и перерисует элемент.</p>
  </li>
</ul>

<h4 id="иерархия">Иерархия</h4>

<p>Вызовы всех методов <code class="highlighter-rouge">View</code> проходят от базового <code class="highlighter-rouge">View</code> к потомкам, сверху вниз.</p>

<p><img src="img/parent-child.jpg" height="600px" /></p>

<p>Во время расчета размера <code class="highlighter-rouge">View</code> потомок принимает “пожелания” от родителя, рассчитывает свои размеры, а также размеры своих потомков. (Measure pass)</p>

<p><img src="img/parent-child-measure.jpg" height="600px" /></p>

<p>После того как размеры известны, родитель проставляет размеры и расположение своим потомкам. (Layout pass)</p>

<p><img src="img/parent-child-layout.jpg" height="600px" /></p>

<p>Последним этапом является отрисовка. Она также происходит от родителя к потомку</p>

<p><img src="img/parent-child-draw.jpg" height="600px" /></p>

<h4 id="шпаргалка">Шпаргалка</h4>

<ul>
  <li>Если есть возможность обойтись без кастомных <code class="highlighter-rouge">View</code>, воспользуйтесь ей;</li>
  <li>Внимательно отнеситесь к расчету размера <code class="highlighter-rouge">View</code>, это поможет избежать множества проблем;</li>
  <li>Во время отрисовки не создавайте лишних объектов и не делайте лишней работы;</li>
  <li>Вызывайте метод <code class="highlighter-rouge">invalidate</code> только когда это действительно нужно;</li>
  <li>Отрисовка происходит в px, но оперировать нужно в терминах <code class="highlighter-rouge">dp</code> и <code class="highlighter-rouge">sp</code>;</li>
  <li>Используйте методы, которые могут упростить ваши расчеты, такие как <code class="highlighter-rouge">resolveSize</code>;</li>
</ul>

<h2 id="что-почитать">Что почитать</h2>

<ul>
  <li>https://developer.android.com/guide/topics/ui/how-android-draws.html</li>
  <li>https://developer.android.com/reference/android/view/View.html</li>
  <li>https://www.raywenderlich.com/142-android-custom-view-tutorial</li>
</ul>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
