<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Создание Hello World приложения Advanced level | Android курс в Технополисе 2019</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Создание Hello World приложения Advanced level" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/01_intro/013_advanced_hello_world/" />
<meta property="og:url" content="http://localhost:4000/01_intro/013_advanced_hello_world/" />
<meta property="og:site_name" content="Android курс в Технополисе 2019" />
<script type="application/ld+json">
{"url":"http://localhost:4000/01_intro/013_advanced_hello_world/","headline":"Создание Hello World приложения Advanced level","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=d3418c91688b3f949df607a428f4549250f0b594">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">Android курс в Технополисе 2019</a></h1>
      

      <p>В этом уроке мы продолжим работать с приложение Hello World: немного усложним верстку и добавим к нему интерактивности. Более внимательно рассмотрим структуру проекта и найдем в нем кое-что лишнее и ненужное, научимся запускать приложение на реальном устройстве вместо эмулятора, а также научимся обходиться без Android Studio для некоторых задач разработки. Бонус – после завершения этого урока вы станете настоящим Android разработчиком (я обещаю).</p>

<h2 id="задача">Задача</h2>

<p>Мы хотим сделать приложение, в котором вместо приветствимя <em>“Hello, World!”</em> на экране будет отображаться персонализированное приветствие с именем пользователя вида <em>“Hello, &lt;username&gt;!”</em>. Для этого мы добавим на экран
поле ввода, куда пользователь будет вводить своё имя и кнопку для подтверждения ввода, по нажатию на которую
и будет выводиться текст сообщения с именем пользователя.</p>

<h2 id="добавление-второй-активности">Добавление второй активности</h2>

<p>Создайте новый класс активности в том же Java пакете и назовите его <code class="highlighter-rouge">HelloUsernameActivity</code>. Пусть этот класс также наследует от <code class="highlighter-rouge">android.app.Activity</code>. UI этой активности будет отличаться от <code class="highlighter-rouge">HelloWorldActivity</code>, но для начала, чтобы просто убедиться, что вторая активность работает, скопируйте файл верстки <code class="highlighter-rouge">activity_hello_world</code> в <code class="highlighter-rouge">activity_hello_username</code> и загрузите этот файл верстки в методе <code class="highlighter-rouge">onCreate</code> класса <code class="highlighter-rouge">HelloUsernameActivity</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class HelloUsernameActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_hello_username);
    }
}
</code></pre></div></div>

<p>Для того, чтобы экраны визуально отличались, замените строковый ресурс <code class="highlighter-rouge">hello_world</code> на новый ресурс <code class="highlighter-rouge">hello_username</code> в файле верстки <code class="highlighter-rouge">activity_hello_username</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;TextView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    android:text="@string/hello_username"/&gt;
</code></pre></div></div>

<p>Добавьте новый строковый ресурс <code class="highlighter-rouge">hello_username</code> в файл <code class="highlighter-rouge">app/src/main/res/values/strings.xml</code> с каким-нибудь уникальным значением. Сейчас файл <code class="highlighter-rouge">strings.xml</code> должен выглядеть приблизительно так:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;resources&gt;
    &lt;string name="app_name"&gt;HelloWorld&lt;/string&gt;
    &lt;string name="hello_world"&gt;Hello, World!&lt;/string&gt;
    &lt;string name="hello_username"&gt;Hello, &amp;lt;Username&amp;gt;!&lt;/string&gt;
&lt;/resources&gt;
</code></pre></div></div>

<p>Как мы уже знаем, все активности приложения обязательно должны быть прописаны в манифесте. Откройте файл <code class="highlighter-rouge">app/src/main/AndroidManifest.xml</code> и добавьте внутрь <code class="highlighter-rouge">application</code> еще один элемент <code class="highlighter-rouge">activity</code> для нашей новой активности <code class="highlighter-rouge">HelloUsernameActivity</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;activity android:name=".HelloUsernameActivity"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN"/&gt;
            &lt;category android:name="android.intent.category.LAUNCHER"/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

</code></pre></div></div>

<p>Здесь мы прописали для нашей второй активности action=MAIN и category=LAUNCHER – так же, как для первой активности <code class="highlighter-rouge">HelloWorldActivity</code>. Как мы помним, такие параметры активности означают, что это основная точка входа в приложение, и для неё будет создана иконка на домашнем экране смартфона. Стоп! Как могут быть две основные точки входа в приложение?…  Оказывается, могут. Основная не значите единственная. Что именно это значит, мы обсудим чуть позже в этом уроке, а пока запустим приложение на эмуляторе.</p>

<p>После старта приложения мы, как и раньше, увидим экран ссобщением “Hello, World”, а вот если закрыть этот экран и посмотреть на список приложений в домашнем экране эмулятора, то мы увидим, что теперь в списке есть два одинаковых ярлыка с одинаковым названием “HelloWorld” – это и есть две наших активности, которые обе приписаны в манифесте, как MAIN.</p>

<p><img src="img/0500_two_main_activities.png" width="400px" /></p>

<p>Ярлыки имеют одинаковые иконки и названия, потому что в манифесте у активноестей не указаны никакие специальные иконки и названия, и поэтому используются значения <code class="highlighter-rouge">icon</code> (<code class="highlighter-rouge">roundIcon</code>) и <code class="highlighter-rouge">label</code> элемента <code class="highlighter-rouge">application</code> манифеста:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"&gt;
</code></pre></div></div>

<p>Чтобы различать ярлыки активностей, создайте для них в файле <code class="highlighter-rouge">app/src/main/res/values/strings.xml</code> строковые ресурсы с уникальными именами:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;string name="activity_hello_world"&gt;Hello World&lt;/string&gt;
    &lt;string name="activity_hello_user"&gt;Hello User&lt;/string&gt;
</code></pre></div></div>

<p>и используйте их в качестве значения атрибута <code class="highlighter-rouge">label</code> в манифесте:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;activity android:name=".HelloWorldActivity"
              android:label="@string/activity_hello_world"&gt;
		...

    &lt;activity android:name=".HelloUsernameActivity"
              android:label="@string/activity_hello_user"&gt;
		...
</code></pre></div></div>

<p>Теперь в списке приложений на домашнем экране яплыки будут иметь разные названия, и мы сможем различать наши две активности:</p>

<p><img src="img/0510_two_main_activities.png" width="400px" /></p>

<p>Осталась последняя проблема – в нашем Hello World приложении сейчас есть два экрана, и мы можем запускать любой из них, выбирая нужную иконку в домашнем экране смартфона, но при запуске из Android Studio будет всегда запускаться экран Hello World. Мы же хотим сейчас сфокусироваться на разработке экрана Hello User, и было бы удобно, чтобы при запуске из Android Studio запускался именно он. Для это добавьте категорию <code class="highlighter-rouge">DEFAULT</code> в <code class="highlighter-rouge">intent-filter</code> активности <code class="highlighter-rouge">HelloUsernameActivity</code> в манифесте:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;activity android:name=".HelloUsernameActivity"
              android:label="@string/activity_hello_user"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN"/&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
            &lt;category android:name="android.intent.category.LAUNCHER"/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre></div></div>

<p>Категория DEFAULT говорит о том, что если для выполнения какого-то действия внутри одного приложения есть несколько вариантов (в данном случае – две разные активности MAIN), то система выберет то действие, которое имеет категорию DEFAULT. Android Studio, которая выполняет запуск нашего приложения на эмуляторе по нажатию на кнопку Run, тоже понимает манифест приложения и запускает активность с категорией DEFAULT.</p>

<p>Есть другой способ сказать Android Studio, какую активность запускать по нажатию на Run: в настройках конфигурации запуска (Чтобы открыть настройки конфигураций запуска, выберите <em>Edit Configurations</em> в drop-down списке слева от кнопки Run в верхней панели инструментов) есть раздел <em>Launch Options</em> – там можно выбрать вариант <em>Specified Activity</em> и затем выбрать какую-то конкретную активность для запуска.</p>

<p><img src="img/0520_edit_launch_options.png" width="1200px" /></p>

<p>Разница между этими вариантами заключается в том, что категория DEFAULT у одного из двух равнозначных варинатов – это свойство самого приложения, известное операционной системе и другим приложениям. А настройки Android Stuidio – это… всего лишь её настройки.</p>

<h2 id="верстка-экрана-hello-user">Верстка экрана Hello User</h2>

<p>Сейчас мы сделаем верстку экрана Hello User с интерактивными элементами, которая выглядит вот так:</p>

<p><img src="img/0530_hello_user_layout.png" width="400px" /></p>

<p>Сначала идет статический текст “Меня зовут”, приглашающий пользователя ввести своё имя, потом поле ввода имени, кнопка подтверждения “Привет” и текст приветствия, который должен содержать введённое пользователем имя вместо <em>&lt;Username&gt;</em>.</p>

<p>Откройте файл верстки <code class="highlighter-rouge">activity_hello_username</code> и отредактируйте его, чтобы он выглдядел так:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;LinearLayout</span>
    <span class="na">xmlns:android=</span><span class="s">"http://schemas.android.com/apk/res/android"</span>
    <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
    <span class="na">android:layout_height=</span><span class="s">"match_parent"</span>
    <span class="na">android:orientation=</span><span class="s">"vertical"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;TextView</span>
        <span class="na">android:layout_width=</span><span class="s">"wrap_content"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>
        <span class="na">android:text=</span><span class="s">"@string/my_name_is"</span>
        <span class="na">android:textSize=</span><span class="s">"18sp"</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;EditText</span>
        <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;Button</span>
        <span class="na">android:layout_width=</span><span class="s">"wrap_content"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>
        <span class="na">android:text=</span><span class="s">"@string/hi"</span><span class="nt">/&gt;</span>

    <span class="nt">&lt;TextView</span>
        <span class="na">android:layout_width=</span><span class="s">"wrap_content"</span>
        <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>
        <span class="na">android:text=</span><span class="s">"@string/hello_username"</span>
        <span class="na">android:textSize=</span><span class="s">"18sp"</span><span class="nt">/&gt;</span>

<span class="nt">&lt;/LinearLayout&gt;</span>
</code></pre></div></div>

<p>В этой верстке есть несколько новых моментов:</p>

<ul>
  <li>В качестве корневого элемента теперь используется <code class="highlighter-rouge">LinearLayout</code>, а не <code class="highlighter-rouge">FrameLayout</code>. FrameLayout слишком простой – он хорош для того, чтобы просто отобразить что-то внутри себя, но не может упорядочить View. LinearLayout позволяет отображать View один за другим по вертикали или по горизонтали. В данном случае – по вертикали, о чем говорит атрибут <code class="highlighter-rouge">orientation="vertical"</code>.</li>
  <li>У элементов <code class="highlighter-rouge">TextView</code> используется атрибут <code class="highlighter-rouge">textSize</code> для изменения размера текста (чтобы текст на скриншоте выше было лучше видно). Значение этого атрибута <code class="highlighter-rouge">18sp</code> использует единицу измерения <code class="highlighter-rouge">sp</code> (scaled pixels). Эта единица измерения используется обычно для текста, и её особенность заключается в том, что она учитывает системные настройки размера экранных текстов.</li>
  <li>Для поля ввода используется <code class="highlighter-rouge">EditText</code> – это стандартный системный класс <code class="highlighter-rouge">android.widget.EditText</code>.</li>
  <li>Для кнопки используется <code class="highlighter-rouge">Button</code> – это <code class="highlighter-rouge">android.widget.Button</code></li>
  <li><code class="highlighter-rouge">Button</code> являются подклассом <code class="highlighter-rouge">TextView</code> (так же, как и <code class="highlighter-rouge">EditText</code>), поэтому у него есть атрибут <code class="highlighter-rouge">text</code>, который здесь используется для надписи на кнопке.</li>
</ul>

<p>В верстке использованы новые строковые ресурсы <code class="highlighter-rouge">my_name_is</code> и <code class="highlighter-rouge">hi</code> – добавьте их в файл со строковыми ресурсами <code class="highlighter-rouge">app/src/main/res/values/strings.xml</code> и не забудьте про переводы на русский язык в <code class="highlighter-rouge">app/src/main/res/values-ru/strings.xml</code>.</p>

<h2 id="поиск-view-по-id">Поиск View по ID</h2>

<p>Мы собираемся добавить код, который будет обрабатывать клик на <code class="highlighter-rouge">Button</code> и использовать ввод из <code class="highlighter-rouge">EditText</code>. Но прежде, чем мы сможем писать какую-то логику работы с View в коде, нам нужно получить доступ к этим View из кода, потому что на данный момент нужные нам View определены только в файле вёрстки. Для связи кода с вёрсткой нам помогут View ID.</p>

<p>У класса <code class="highlighter-rouge">View</code> есть свойство <code class="highlighter-rouge">id</code> типа <code class="highlighter-rouge">int</code>, которое доступно разработчикам через сеттер <code class="highlighter-rouge">View.setId(int id)</code> и геттер <code class="highlighter-rouge">int View.getId()</code>. По умолчанию View имеет нулевой ID: <code class="highlighter-rouge">getId() == 0</code>, но в файле вёрски можно указать какое-то значение атрибута <code class="highlighter-rouge">id</code>, и View получит отличный от нуля идентификатор. Делается это при помощи следующего синтаксиса:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;View
    android:id="@+id/unique_id_name"
	android:layout_width="wrap_content"
    android:layout_height="wrap_content"/&gt;
</code></pre></div></div>

<p>Здесь используется специальный синтаксис ссылки на ID ресурса со знаком плюс: <code class="highlighter-rouge">@+id/unique_id_name</code>. Знак плюс означает, что мы не ссылаемся на какой-то ресурс, который определен в другом месте (как мы делали со строками), а определяем его прямо здесь по месту использования. Если бы мы использовали синтаксис без плюса, до произошла бы ошибка сборки из-за того, что мы ссылаемся на ресурс, который нигде не определен. Однако, если ID какого-то View уже был однажды определен в верстке, то в других местах можно использовать синтаксис ссылки на этот ID без плюса – в случаях, когда мы явно хотим сказать: “Где-то должен  быть такой ID, и мы хотим использовать именно его”. Пример:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;View
    android:id="@+id/unique_id_name"
	android:layout_width="wrap_content"
    android:layout_height="wrap_content"/&gt;

&lt;View
	android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:layout_constraintLeftToRightOf="@id/unique_id_name"/&gt;
</code></pre></div></div>

<p>Для каждого ID, определенного таким образом в файле верстки, будет сгенерирована константа <code class="highlighter-rouge">R.id.unique_id_name</code>, котороую можно использовать в коде для работы с View. Самый частый кейс использования таких констант – поиск View по ID в загруженной из файла верстки иерархии View. Для этого у класса <code class="highlighter-rouge">Activity</code> есть метод:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Nullable
public &lt;T extends View&gt; T findViewById(@IdRes int id);
</code></pre></div></div>
<p>Он принимает в качестве аргумента ID (Аннотация <code class="highlighter-rouge">@IdRes</code> говорит, что это должно быть не произвольное значение, а какая-то константа из <code class="highlighter-rouge">R.id</code>), и возвращает инстанс <code class="highlighter-rouge">View</code> с таким ID из ранее загруженной иерархии View. Если <code class="highlighter-rouge">View</code> с таким ID не найден, то метод вернет <code class="highlighter-rouge">null</code>. Очевидно, использовать этот метод надо после вызова <code class="highlighter-rouge">setContentView</code>, когда иерархия View уже загружена.</p>

<p><em>На заметку №1: метод <code class="highlighter-rouge">findViewById</code> реализован обходом в глубину (DFS). Возомжна ситуация, в которой разные View в иерархии имеют одинаковые ID – в таком случае будет найдено первое View в порядке обхода DFS.</em></p>

<p><em>На заметку №2: использование констант ресурсов из <code class="highlighter-rouge">R.id</code> в качестве View ID не является строго обязательным. Технически возможно использовать произвольные значения, устанавливая их из кода сеттером <code class="highlighter-rouge">View.setId</code>. Однако, делать это не рекомендуется, потому что в андроидном UI движке View ID используются повсеместно, и неправильное их использование может что-нибудь сломать. Опасаться следует в первую очередь непредвиденных коллизий ID там, где их быть не должно.</em></p>

<p>Теперь добавьте ID в верстку. ID нужны только у тех View, с которыми мы будем работать в коде:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;EditText
    android:id="@+id/input_name"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/&gt;

&lt;Button
    android:id="@+id/btn_submit"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hi"/&gt;

&lt;TextView
    android:id="@+id/message_text"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/hello_username"
    android:textSize="18sp"/&gt;
</code></pre></div></div>

<p>Добавьте поля для нужных нам View в классе <code class="highlighter-rouge">HelloUsernameAcitvity</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private EditText nameEditText;
private TextView messageText;
</code></pre></div></div>

<p>Поле <code class="highlighter-rouge">nameEditText</code> будет использоваться для доступа к <code class="highlighter-rouge">EditText</code>, в который пользователь вводит имя, а <code class="highlighter-rouge">messageText</code> – для <code class="highlighter-rouge">TextView</code>, в котором мы будем отображать сообщение после нажатия на кнопку. Нам не нужно поле для кнопки, потому что, хоть мы и будем писать код для работы с кнопкой, нам будет достаточно локальной переменной для хранения ссылки на кнопку.</p>

<p>Теперь, когда всем View назначены ID в файле верстки, а в классе активности определены поля для хранения ссылок на View, нам осталось получить инстансы View и сохранить их в поля. Для этого мы используем метод <code class="highlighter-rouge">Activity.findViewById</code>, который можно вызывать из метода <code class="highlighter-rouge">onCreate</code> после вызова <code class="highlighter-rouge">setContentView</code>. Метод <code class="highlighter-rouge">onCreate</code> в классе <code class="highlighter-rouge">HelloUsernameActivity</code> теперь выглядит так:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_hello_username);
        
        final View btnSubmit;
        
        nameEditText = findViewById(R.id.input_name);
        messageText = findViewById(R.id.message_text);
        btnSubmit = findViewById(R.id.btn_submit);
    }
</code></pre></div></div>

<h2 id="обработка-кликов">Обработка кликов</h2>

<p>Для обработки кликов в Android UI фреймворке есть специальный интерфейс <code class="highlighter-rouge">View.OnClickListener</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /**
     * Interface definition for a callback to be invoked when a view is clicked.
     */
    public interface OnClickListener {
        /**
         * Called when a view has been clicked.
         *
         * @param v The view that was clicked.
         */
        void onClick(View v);
    }
</code></pre></div></div>

<p>и метод <code class="highlighter-rouge">View.setOnClickListener</code>, при помощи которого можно установить колбэк на View, клики которого вы хотите перехватить:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void setOnClickListener(@Nullable OnClickListener l)
</code></pre></div></div>

<p>Добавьте в декларацию класса <code class="highlighter-rouge">HelloUsernameActivity</code> интерфейс <code class="highlighter-rouge">View.OnClickListener</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class HelloUsernameActivity extends Activity
        implements View.OnClickListener {
</code></pre></div></div>
<p>и пустую реализацию метода <code class="highlighter-rouge">onClick</code> из интерфейса <code class="highlighter-rouge">View.OnClickListener</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    public void onClick(View v) {
        
    }
</code></pre></div></div>

<p>В методе <code class="highlighter-rouge">onCreate</code> добавьте вызов <code class="highlighter-rouge">setOnClickListener</code> на инстансе кнопки (которую мы сохранили в локальную переменную <code class="highlighter-rouge">View btnSubmit</code>), передав ему в качестве параметра ссылку на <code class="highlighter-rouge">this</code> инстанс <code class="highlighter-rouge">HelloUsernameActivity</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	btnSubmit.setOnClickListener(this);
</code></pre></div></div>

<p>Чтобы проверить, что перехват клика на кнопку работает, можно добавить в метод <code class="highlighter-rouge">onClick</code> печать в лог:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    public void onClick(View v) {
        Log.d("HelloWorld", "HelloUsernameActivity.onClick: clicked on view " + v);
    }
</code></pre></div></div>

<p>Теперь запустите приложение и покликайте на кнопку “Привет” в эмуляторе. Если всё сделано правильно, то в логе на каждый клик будет печататься сообщение такого вида:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2019-01-21 02:43:17.429 D/HelloWorld: HelloUsernameActivity.onClick: clicked on view android.widget.Button{65114ec VFED..C.. ......ID 0,209-264,353 #7f070021 app:id/btn_submit}
</code></pre></div></div>

<p>Для просмотра лога нужно переключиться на вкладку <code class="highlighter-rouge">Logcat</code> в нижней части экрана. Для удобства просмотра логи можно отфильтровать, например по слову <em>hello</em> – так мы будем видеть только интересующие нас сообщения.
<img src="img/0540_log_click.png" width="1200px" /></p>

<p>Как можно увидеть из лога, на каждый клик вызывается колбек <code class="highlighter-rouge">onClick</code>, который мы определили в <code class="highlighter-rouge">HelloUsernameActivity</code>, и в качестве параметра ему передаётся инстанс <code class="highlighter-rouge">View</code>, по которому был совершен клик (в данном случае это инстанс <code class="highlighter-rouge">android.widget.Button</code> с ID <code class="highlighter-rouge">btn_submit</code>). Один и тот же инстанс <code class="highlighter-rouge">View.OnClickListener</code> можно использовать для перехвата кликов по разным <code class="highlighter-rouge">View</code>, поэтому хорошей практикой будет проверять в методе <code class="highlighter-rouge">onClick</code>, что это за инстанс <code class="highlighter-rouge">View</code> пришел в качестве параметра, и в зависимости от вариантов, выполнять те или иные действия. В нашем примере мы перехватываем клики только у одной кнопки, но мы всё равно напишем код чисто:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    @Override
    public void onClick(View v) {
        Log.d("HelloWorld", "HelloUsernameActivity.onClick: clicked on view " + v);
        if (v.getId() == R.id.btn_submit) {
            onSubmitBtnClicked();
        }
    }

    private void onSubmitBtnClicked() {

    }
</code></pre></div></div>

<p>Добавленный нами метод <code class="highlighter-rouge">onSubmitBtnClicked()</code> будет вызываться только тогда, когда произошел клик на кнопку подтверждения, и в нем мы напишем логику обработки ввода: нам нужно взять текст из <code class="highlighter-rouge">EditText</code> (инстанс которого мы сохранили в поле <code class="highlighter-rouge">nameEditText</code>), сгенерировать из него сообщение и вывести его в <code class="highlighter-rouge">TextView</code> (поле <code class="highlighter-rouge">messageText</code>).</p>

<p>Для того, чтобы сформировать сообщение, мы будем использовать технологию форматирования строк при помощи ресурсов. То есть, вместо того, чтоб написать в коде что-то вроде <code class="highlighter-rouge">String message = "Hello, " + userName</code>, мы определим строковый ресурс, содержащий сообщение с аргументами (замените старое значение ресурса <code class="highlighter-rouge">hello_username</code> на новое):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	&lt;string name="hello_username"&gt;Hello, %1$s!&lt;/string&gt;
</code></pre></div></div>
<p>и его вариант для русской локали:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;string name="hello_username"&gt;Привет, %1$s!&lt;/string&gt;
</code></pre></div></div>
<p>а в коде получим отформатированное сообщение при помощи вызова метода <code class="highlighter-rouge">getString(@StringRes int formatResId, Object ... args)</code>, передав ему строку с именем пользователя, которая будет подставлена вместо <code class="highlighter-rouge">%1$s</code>. Этот метод определен в классе <code class="highlighter-rouge">Context</code>, а наша активность <code class="highlighter-rouge">HelloUsernameActivity</code> сама является экземпляром активности, поэтому мы можем вызывать этот метод в коде <code class="highlighter-rouge">onSubmitBtnClicked()</code>, который теперь должен выглядеть так:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    private void onSubmitBtnClicked() {
        String name = nameEditText.getText().toString();
        String message = getString(R.string.hello_username, name);
        messageText.setText(message);
    }
</code></pre></div></div>

<p>Использование форматирования при помощи ресурсов более предпочтительно, чем форматирования при помощи простой конктенации в коде, потому что при таком способе используется система локализации, и вы можете использовать разные форматы на разных языках – ведь, даже если вы переведете отдельные фрагменты фразы на все языки, порядок следования этих фрагментов может отличаться в разных языках, и вычисление правильной фразы в коде может оказаться слишком сложным (если вообще возможным).</p>

<p>Теперь в нашем приложении Hello Username функционал почти готов. Его можно запустить, ввести в поле ввода имя, нажать на кнопку, и результат будет выглядеть так:</p>

<p><img src="img/0550_hello_dmitry.png" width="400px" /></p>

<p>Есть одна небольшая проблема: при старте приложения, когда кнопка еще не нажата, мы видим текст сообщения с служебными символами форматирования: <code class="highlighter-rouge">Привет, %1$s!</code> – потому что код метода <code class="highlighter-rouge">onSubmitBtnClicked</code> еще не отработал, да и нет еще никакого введенного пользователем имени. По-хорошему, сообщение вообще не должно отображаться, пока пользователь не кликнул на кнопку. Мы так и сделаем, во время инициализации UI в методе <code class="highlighter-rouge">onCreate</code> мы скроем <code class="highlighter-rouge">TextView</code> c сообщением, а в методе <code class="highlighter-rouge">onSubmitBtnClicked</code>, мы снова покажем <code class="highlighter-rouge">TextView</code> с сообщением. Для этого мы используем свойство <code class="highlighter-rouge">visibility</code>, которое есть у <code class="highlighter-rouge">View</code>.</p>

<h2 id="view-visibility">View Visibility</h2>

<p>У <code class="highlighter-rouge">View</code> есть свойство <code class="highlighter-rouge">visibility</code>, которое имеет тип <code class="highlighter-rouge">int</code> и доступное через геттер <code class="highlighter-rouge">getVisibility()</code> и сеттер <code class="highlighter-rouge">setVisibility(int visibility)</code>. Возможные значения <code class="highlighter-rouge">visibility</code>:</p>
<ul>
  <li><code class="highlighter-rouge">View.VISIBLE</code> – это дефолтное значение, <code class="highlighter-rouge">View</code> отображается нормально.</li>
  <li><code class="highlighter-rouge">View.INVISIBLE</code> – <code class="highlighter-rouge">View</code> становится невидимым, но при этом занимает место в вёрстке.</li>
  <li><code class="highlighter-rouge">View.GONE</code> – <code class="highlighter-rouge">View</code> невидимо, и не занимает место в вёрстке.</li>
</ul>

<p>Устанавливая значение <code class="highlighter-rouge">visibility</code> из кода, можно управлять его видимостью в UI.
<img src="img/0560_visibility_demo.png" width="800px" /></p>

<p>Чтобы решить проблему несвоевременного отображения сообщения, добавьте следующий код в метод <code class="highlighter-rouge">HelloUsernameActivity.onCreate</code> (после присваивания значения полю <code class="highlighter-rouge">messageText</code>):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    messageText.setVisibility(View.INVISIBLE);
</code></pre></div></div>
<p>и следующий код – в метод <code class="highlighter-rouge">onSubmitButtonClicked</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	messageText.setVisibility(View.VISIBLE);
</code></pre></div></div>

<p>Теперь при старте приложения <code class="highlighter-rouge">TextView</code> с неправильным текстом на экране не отображается, а после клика на кнопку появляется правильно отформатированный текст.</p>

<h2 id="запуск-activity-из-кода">Запуск Activity из кода</h2>

<p>Мы сделали приложение, состоящее из двух Activity, каждая из которых прописана в манифесте как точка входа с домашнего экрана. Это, на самом деле, редко используемая практика. Обычно одно приложение размещает на домашнем экране один ярлык, соответствующий главной точке входа в приложение – основнуу её активность, а уже внутри приложения пользователь переходим между разными экранами.</p>

<p>Сейчас мы сделаем так же: создадим активность <code class="highlighter-rouge">MainActivity</code> с двумя кнопками, по клику на которые будет происходить переход в <code class="highlighter-rouge">HelloWorldActivity</code> либо в <code class="highlighter-rouge">HelloUsernameActivity</code>. И только одна <code class="highlighter-rouge">MainAcitvity</code> будет запускаться из домашнего экрана устройства.</p>

<p>Для запуска Activity из кода мы будем использовать Intent (интент) – это абстрактное описание чего-то, что вы хотите запустить. Интенты широко используются в Android и являются основным способом запуска других приложений, активностей, сервисов – практически всего, что можно запустить.</p>

<p>Интенты создаются при помощи класса <code class="highlighter-rouge">android.content.Intent</code> в документации к которому (<a href="https://developer.android.com/reference/android/content/Intent">https://developer.android.com/reference/android/content/Intent</a>) можно прочитать про разные способы запуска других активностей при помощи интентов. Общий принцип работы интентов такой: вы в общих чертах описываете, что вы хотите запустить, а операционная система находит подходящее под описание приложение и активность в нём. Наприм, вы можете захотеть запустить какое-нибудь приложение, которое умеет отображать географические координаты (которые задаются при помощи URI со схемой <code class="highlighter-rouge">geo:</code>) – система по такому интенту предолжит вам разнообразные картографические приложения и навигаторы.</p>

<p>Мы же будем использовать самый простой вариант, когда вместо абстрактного описания того, что мы хотим запустить, мы явно укажем приложение и Acitivity в нём, а система его для нас запустит. Для этого используется такой конструктор <code class="highlighter-rouge">Intent</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Intent(Context packageContext, Class&lt;Activity&gt; activityClass);
</code></pre></div></div>
<p>Первый параметр указывает на контекст приложения, которое мы хотим запустить (если мы выполняем код внутри Activity, то можем использовать <code class="highlighter-rouge">this</code>, потому что <code class="highlighter-rouge">Activity</code> является контекстом нашего собственного приложения). Второй параметр указывает на активность внутри нашего приложения, которую мы хотим запустить.</p>

<p>Имея объект интента, запуск активности выполняется при помощи метода <code class="highlighter-rouge">Context.startActivity(Intent intent)</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Intent intent = new Intent(this, HelloWorldActivity.class);
startActivity(intent);
</code></pre></div></div>
<p>Нужно иметь в виду, что может оказаться, что система не сможет найти подходящее приложение и активность для вашего интента, и в таком случае будет выброшено исключение <code class="highlighter-rouge">ActivityNotFoundException</code>, которое надо поймать и что-то предринять:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>try {
	startActivity(intent);
} catch (ActivityNotFoundException e) {
	// TODO: notify user or navigate to Google Play to install the missing app?
}
</code></pre></div></div>

<h2 id="добавляем-mainactivity">Добавляем MainActivity</h2>

<p>Создайте класс активности <code class="highlighter-rouge">MainActivity</code> в пакете <code class="highlighter-rouge">ru.ok.technopolis.helloworld</code> и добавьте её в манифест с интент-фильтром MAIN+LAUNCHER (такой же, как мы использовали для <code class="highlighter-rouge">HelloWorldActivity</code>), а у активностей <code class="highlighter-rouge">HelloWorldActivity</code> и <code class="highlighter-rouge">HelloUsernameActivity</code> уберите интент-фильтры (они больше не нужны, потому что эти активности теперь будут запускаться из кода, а не из домашнего экрана):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;activity android:name=".MainActivity"
                  android:label="@string/app_name"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="android.intent.action.MAIN"/&gt;
        &lt;category android:name="android.intent.category.LAUNCHER"/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity android:name=".HelloWorldActivity"
          android:label="@string/activity_hello_world"/&gt;

&lt;activity android:name=".HelloUsernameActivity"
          android:label="@string/activity_hello_user"/&gt;
</code></pre></div></div>

<p>Создайте файл верстки <code class="highlighter-rouge">activity_main.xml</code> с двумя кнопками:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"&gt;

    &lt;Button
        android:id="@+id/btn_hello_world"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/activity_hello_world"/&gt;

    &lt;Button
        android:id="@+id/btn_hello_user"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/activity_hello_user"/&gt;

&lt;/LinearLayout&gt;
</code></pre></div></div>
<p>В качестве текста для кнопок здесь используются ранее созданные ресурсы <code class="highlighter-rouge">@string/activity_hello_world</code> и <code class="highlighter-rouge">@string/activity_hello_user</code>, а для ID кнопок мы создали новые ресурсы типа id: <code class="highlighter-rouge">@+id/btn_hello_world</code> и <code class="highlighter-rouge">@+id/btn_hello_user</code> – их мы будем использовать в коде для обработки кликов.</p>

<p>В классе <code class="highlighter-rouge">MainActivity</code> напишите код, который загружает верстку и устанавливает обработчики кликов на кнопки:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    findViewById(R.id.btn_hello_world).setOnClickListener(this);
    findViewById(R.id.btn_hello_user).setOnClickListener(this);
}
</code></pre></div></div>
<p>и добавьте тело метода обработчика клика (обрабочтичком клика является сам класс <code class="highlighter-rouge">MainActivity</code>, поэтому он должен объявить интерфейс обработчика кликов <code class="highlighter-rouge">implements View.OnClickListener</code>):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Override
public void onClick(View v) {

}
</code></pre></div></div>

<p>В этом методе мы должны определить, какая кнопка нажата, и запустить соответсввующую активность при помощи явного интента. Вот код, который это делает:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (v.getId() == R.id.btn_hello_user) {
    startActivity(new Intent(this, HelloUsernameActivity.class));
} else if (v.getId() == R.id.btn_hello_world) {
    startActivity(new Intent(this, HelloWorldActivity.class));
}
</code></pre></div></div>

<p>Если всё сделано правильно, то теперь при запуске приложения мы увидим экран <code class="highlighter-rouge">MainActivity</code> с двумя кнопками, и сможем переходить в другие экраны, кликая на кнопки, и возвращаться назад в <code class="highlighter-rouge">MainAсtivity</code> нажатием на Back.</p>

<p><img src="img/0570_hello_demo.gif" width="360px" /></p>

<h2 id="заключение">Заключение</h2>

<p>Вот список тем, которые были освещены в этом уроке:</p>
<ul>
  <li>Добавление второй активности в приложение</li>
  <li>Категория DEFAULT для intent-filter в манифесте</li>
  <li>Конфигурации для запуска в Android Studio</li>
  <li>Ярлыки активностей</li>
  <li>Верстка: <code class="highlighter-rouge">EditText</code> для пользовательского ввода</li>
  <li>Верстка: <code class="highlighter-rouge">Button</code> для кнопки</li>
  <li>Верстка: <code class="highlighter-rouge">LinearLayout</code></li>
  <li>View ID, метода <code class="highlighter-rouge">findViewById</code> для поиска View</li>
  <li>Обработка кликов, интерфейс <code class="highlighter-rouge">View.OnClickListener</code></li>
  <li>Форматирование тектса при помощи строковых ресурсов</li>
  <li>View Visibility</li>
  <li>Запуск Activity из кода при помощи Intent</li>
</ul>



      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
